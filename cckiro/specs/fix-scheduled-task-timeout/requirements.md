# 要件定義: スケジュールタスクのタイムアウト問題の解決

## 1. 問題の概要

`test_scheduled_listed_info_api.py` テストスクリプトが、スケジュールタスクの実行を 300 秒待機してもタイムアウトしてしまう問題が発生しています。

### 現状の動作
1. テストスクリプトが API を通じてスケジュールを作成（1 分後に実行）
2. Celery Beat がスケジュールを認識して実行するまで待機
3. 実行履歴 API をポーリングして結果を確認
4. 300 秒経過してもタスクが実行されず、タイムアウト

### 根本原因
- `DatabaseScheduler`が 60 秒ごとにしかデータベースからスケジュールを再読み込みしない
- 新規作成されたスケジュールが最大 60 秒間認識されない可能性がある
- テストスクリプトは 1 分後の実行を期待しているが、スケジューラーの同期タイミングによっては実行されない

## 2. 機能要件

### 2.1 スケジューラーの即時同期機能
- 新しいスケジュールが作成されたときに、 Celery Beat に即座に通知する仕組みが必要
- スケジュール作成後、即座にタスクの実行が可能になること

### 2.2 テスト可能性の向上
- テストスクリプトが確実にタスクの実行を検証できること
- タイムアウトせずに適切な時間内で結果を確認できること

### 2.3 パフォーマンス要件
- スケジューラーの同期処理が頻繁に実行されても、システムのパフォーマンスに影響を与えないこと
- データベースへの負荷を最小限に抑えること

## 3. 非機能要件

### 3.1 互換性
- 既存のスケジュール機能との後方互換性を維持すること
- 既存の API インターフェースを変更しないこと

### 3.2 信頼性
- スケジュールの実行が確実に行われること
- 同期処理の失敗がシステム全体に影響を与えないこと

### 3.3 運用性
- ログで同期処理の状態を確認できること
- エラー発生時に適切なエラーメッセージが出力されること

## 4. 制約事項

- Celery Beat の基本的なアーキテクチャは変更しない
- データベーススキーマの変更は最小限に抑える
- 既存の Celery タスクの実装は変更しない

## 5. 解決方針の選択肢

### 選択肢 1: スケジューラーの同期間隔を短縮
- メリット: 実装が簡単
- デメリット: データベース負荷が増加、根本的な解決にならない

### 選択肢 2: スケジュール作成時に Celery Beat へ通知
- メリット: 即座に反映される、効率的
- デメリット: 実装が複雑、 Celery Beat との連携が必要

### 選択肢 3: テスト専用の即時実行モード
- メリット: 本番環境に影響なし、テストが確実
- デメリット: テストと本番の動作が異なる

## 6. 推奨アプローチ

**選択肢 2（スケジュール作成時に Celery Beat へ通知）** を推奨します。

理由：
- 根本的な問題を解決する
- ユーザー体験が向上する（スケジュール作成後すぐに実行される）
- テストだけでなく本番環境でも有用

## 7. 成功基準

1. `test_scheduled_listed_info_api.py` がタイムアウトせずに完了すること
2. スケジュール作成から実行までの時間が予測可能であること
3. 既存の機能に影響を与えないこと
4. システムのパフォーマンスが維持されること

## 8. テスト要件

- 単体テスト: スケジューラーの同期処理のテスト
- 統合テスト: スケジュール作成から実行までの一連の流れのテスト
- 負荷テスト: 多数のスケジュールが同時に作成された場合のテスト
- 回帰テスト: 既存機能が正常に動作することの確認